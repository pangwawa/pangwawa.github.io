<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小吴的工作手记</title>
    <link>https://pangwawa.github.io/</link>
    <description>Recent content on 小吴的工作手记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Sun, 22 Mar 2020 18:09:01 +0800</lastBuildDate><atom:link href="https://pangwawa.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL索引与优化</title>
      <link>https://pangwawa.github.io/posts/mysql_index/</link>
      <pubDate>Sun, 22 Mar 2020 18:09:01 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/mysql_index/</guid>
      <description>什么是索引，为什么要使用索引 索引是一种能提高数据查询速度的数据结构， 常用的索引数据解构有 B+ 树 和 Hash
可以提高数据检索的效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗
劣势：
索引会占据磁盘空间
索引虽然会提高查询效率，但是会降低更新表的效率
索引类型 主键索引 索引列中的值必须是唯一的，不允许有空值。 ####普通索引 MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。 ####唯一索引 索引列中的值必须是唯一的，但是允许为空值。 ####全文索引 只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。 ####空间索引 MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。 ####前缀索引 在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。
其他（按照索引列数量分类） ####单列索引 ####组合索引 组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。
为什么很少使用Hash作为索引的数据结构 Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。
什么是B+树，为什么使用B+树作为数据库索引的底层结构，为什么不使用B树 减少磁盘IO操作，就需要尽量降低树的高度，第一个根节点的位置要合理
平衡二叉树：采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。
B树，改造平衡二叉树，降低树的高度，减少磁盘IO操作。B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。
B+树，为了解决B树不支持范围查询的快速查找
B+树和B树最主要的区别在于非叶子节点是否存储数据的问题 B树：非叶子节点和叶子节点都会存储数据。 B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。  MyISAM索引和InnoDB索引的区别 ####MyISAM MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。 先在主键树中从根节点开始检索，将根节点加载到内存，比较28&amp;lt;75，走左路。（1次磁盘IO） 将左子树节点加载到内存中，比较16&amp;lt;28&amp;lt;47，向下检索。（1次磁盘IO） 检索到叶节点，将节点加载到内存中遍历，比较16&amp;lt;28，18&amp;lt;28，28=28。查找到值等于30的索引项。（1次磁盘IO） 从索引项中获取磁盘地址，然后到数据文件user.MYD中获取对应整行记录。（1次磁盘IO） 将记录返给客户端。
InnoDB 索引 InnoDB的数据和索引存储在一个文件t_user_innodb.ibd中。InnoDB的数据组织方式，是聚簇索引。
InnoDB索引按照叶子节点是否存储数据分为主键索引（聚簇索引）和 辅助索引 除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址。
 主键索引的叶子节点会存储数据行，辅助索引只会存储主键值。  回表查询：根据在辅助索引树中获取的主键id，到主键索引树检索数据的过程称为回表查询
组合索引和覆盖索引 组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配。
覆盖索引 覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。 但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。
覆盖索引和联合索引是什么 覆盖索引，返回的字段建立索引，减少回表操作
联合索引，在合理的情况下，尽可能在一个****索引中包含多个字段
覆盖索引的字段可能不是在同一个索引，即覆盖索引中所使用的索引不一定是联合索引</description>
    </item>
    
    <item>
      <title>ElasticSearch倒排索引原理探索</title>
      <link>https://pangwawa.github.io/posts/elasticsearch_inverted_index/</link>
      <pubDate>Thu, 05 Mar 2020 11:20:35 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch_inverted_index/</guid>
      <description></description>
    </item>
    
    <item>
      <title>深入理解LSM存储结构</title>
      <link>https://pangwawa.github.io/posts/lsm_store/</link>
      <pubDate>Mon, 02 Mar 2020 11:18:34 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/lsm_store/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ElasticSearch集群与调优</title>
      <link>https://pangwawa.github.io/posts/elasticsearch_cluster/</link>
      <pubDate>Sat, 29 Feb 2020 11:10:33 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch_cluster/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ElasticSearch 数据导入方案</title>
      <link>https://pangwawa.github.io/posts/elasticsearch_data_input/</link>
      <pubDate>Tue, 25 Feb 2020 11:08:58 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch_data_input/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ElasticSearch用户权限与安全机制</title>
      <link>https://pangwawa.github.io/posts/elasticsearch_account_management_and_security/</link>
      <pubDate>Sat, 22 Feb 2020 10:32:21 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch_account_management_and_security/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ElasticSearch基础概念与架构原理</title>
      <link>https://pangwawa.github.io/posts/elasticsearch__structure/</link>
      <pubDate>Thu, 20 Feb 2020 11:14:21 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch__structure/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ElasticSearch Mapping 数据建模规范与建模过程</title>
      <link>https://pangwawa.github.io/posts/elasticsearch_data_modeling/</link>
      <pubDate>Sun, 16 Feb 2020 09:41:35 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch_data_modeling/</guid>
      <description>##Mapping数据建模
字段类型————是否要搜索及分词————是否要聚合及排序————是否要额外的存储
mapping 设计非常重要，需要从两个维度进行考虑：
功能：搜索、排序、聚合 性能：存储的开锁、内存的开销、搜索的性能 mapping 注意事项：
加入新字段很容易（必要时需要 update_by_query） 更新删除字段不允许（需要 reindex 重建数据）
最佳实践
1、不允许自动新增字段，将 dynamic 设置成 strict。默认为 true；
2、不需要分词的字段，将 type 设置成 keyword。默认使用了多字段特性，text、keyword这2种类型都有；
3、不需要检查的字段，将 index 设置成 false。默认为 true；
4、不需要排序和聚合的字段，将 doc_values 设置成false。默认为 true；
5、不需要检查、排序、聚合的字段，将 enable 设置成 false，仅做存储；
6、type = text 的字段，默认不可以排序，如需要排序，将 fielddata 设置成 true，默认为 false；
7、单个索引避免过多字段，默认最大值为1000；
8、避免空值引起的聚合不准确的问题；
9、避免使用正则查询；
10、尽量不要设计成索引关联，可冗余多一些字段，以空间换时间，如实在无法避免，按以下方式处理：</description>
    </item>
    
    <item>
      <title>Elasticsearch的DSL——常用检索、复合检索、高级检索</title>
      <link>https://pangwawa.github.io/posts/elasticsearch_query_dsl/</link>
      <pubDate>Sat, 15 Feb 2020 17:49:40 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch_query_dsl/</guid>
      <description>简单查询 精准查询term （完全匹配，不使用分词器） term单值查询
{ &amp;quot;query&amp;quot;: { &amp;quot;term&amp;quot;: { &amp;quot;productType&amp;quot;: { &amp;quot;value&amp;quot;: &amp;quot;101&amp;quot; } } } } term多值查询
GET /test/_search { &amp;quot;query&amp;quot;: { &amp;quot;bool&amp;quot;: { &amp;quot;must&amp;quot;: [ { &amp;quot;term&amp;quot;: { &amp;quot;mac&amp;quot;: { &amp;quot;value&amp;quot;: &amp;quot;2541229&amp;quot; } } }, { &amp;quot;term&amp;quot;: { &amp;quot;productType&amp;quot;: { &amp;quot;value&amp;quot;: &amp;quot;1&amp;quot; } } } ] } } } terms查询多值
{ &amp;quot;query&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;productType&amp;quot;:[&amp;quot;101&amp;quot;,&amp;quot;102&amp;quot;] } } } 模糊查询 （模糊匹配，使用分词器） match 、 match_all、multi_match、match_phrase
match_all 匹配所有的， 当不给查询条件时，默认全查 match</description>
    </item>
    
    <item>
      <title>ElasticSearch 生命周期管理——索引生命周期与冷热数据分离</title>
      <link>https://pangwawa.github.io/posts/elasticsearch_lifecycle_management/</link>
      <pubDate>Tue, 11 Feb 2020 09:46:25 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch_lifecycle_management/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ElasticSearch 7.x 数据类型详解</title>
      <link>https://pangwawa.github.io/posts/elasticsearch_datatype/</link>
      <pubDate>Mon, 10 Feb 2020 09:23:44 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/elasticsearch_datatype/</guid>
      <description>基础类型 String类型 keyword
keyword字符串按原样保留以进行过滤和排序。
text
text将对字段值进行分析以进行全文本搜索
数字类型 long
integer
short
byte
double
float
half float
scaled float
时间类型 date
布尔类型 **boolean
二进制类型 binary
区间类型 integer range
float range
long ranage
double range
date range
复杂类型 Array数组
Object对象
Nested类型
GEO地理位置类型 geo point
geo shape
IP类型 ip
自动补全类型 completion
String长度类型 token_count
percolate类型 mumur3
父子索引Join类型 percolator
别名类型 alias</description>
    </item>
    
    <item>
      <title>你好，第一篇手记</title>
      <link>https://pangwawa.github.io/posts/%E4%BD%A0%E5%A5%BD%E7%AC%AC%E4%B8%80%E7%AF%87%E6%89%8B%E8%AE%B0/</link>
      <pubDate>Sun, 09 Feb 2020 15:00:01 +0800</pubDate>
      
      <guid>https://pangwawa.github.io/posts/%E4%BD%A0%E5%A5%BD%E7%AC%AC%E4%B8%80%E7%AF%87%E6%89%8B%E8%AE%B0/</guid>
      <description>关于我  我是一名专注于Java架构和大数据开发的互联网人。 2020，是我毕业后在职场的第二年，但也知道了自己的兴趣方向，明白了生活的不易。之前都是在CSDN https://blog.csdn.net/Jack__iT上写博客，现在想有个专属的小天地。
我也许只是浩瀚星辰中的小星星，但这并无法阻挡我发出自己的光芒。
共勉 忘了在哪看到的这段话，算是挺有意思的鸡汤吧，咱一起喝碗鸡汤补补：
纽约时间比加州时间早三个小时，
New York is 3 hours ahead of California,
但加州时间并没有变慢。
but it does not make California slow.
有人22岁就毕业了，
Someone graduated at the age of 22,
但等了五年才找到好的工作！
but waited 5 years before securing a good job!
有人25岁就当上CEO，
Someone became a CEO at 25,
却在50岁去世。
and died at 50.
也有人迟到50岁才当上CEO，
While another became a CEO at 50,
然后活到90岁。
and lived to 90 years.
有人依然单身，</description>
    </item>
    
  </channel>
</rss>
